<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title>Oracle cheat sheet - Software by Jeff Bourdier</title>
    <meta name="description" content="Oracle cheat sheet page by Jeff Bourdier hosted on GitHub" />
    <meta name="author" content="Jeff Bourdier" />
    <link rel="icon" href="../favicon.ico" />
    <link rel="apple-touch-icon" href="../apple-touch-icon.png" />
    <link rel="stylesheet" type="text/css" href="../common.css" />
    <link rel="stylesheet" type="text/css" href="../mobile.css" media="only screen and (max-device-width: 511px)" />
    <link rel="stylesheet" type="text/css" href="../desktop.css" media="only screen and (min-device-width: 512px)" />
    <style>
      pre span.comment { color: green; }
      pre span.string { color: red; }
      pre span.number { color: fuchsia; }
      pre span.delimiter { color: purple; }
      pre span.keyword { color: blue; }
    </style>
    <script src="ora.js"></script>
    <script type="text/javascript">
      <!--

      /* Uncomment this to track keyword frequency. */
      //var keywordFrequency = [];

      function initPage()
      {
        var elements, i;

        /* Uncomment this to track keyword frequency. */
        //for (i = 0; i < KEYWORDS.length; i++) keywordFrequency.push(0);

        /* Apply syntax-highlighting to each block of preformatted text (which should contain Oracle SQL code). */
        elements = document.body.getElementsByTagName("pre");
        for (i = 0; i < elements.length; i++) highlightSyntax(elements[i]);

        /* Uncomment this to track keyword frequency. */
        //for (i = 0; i < KEYWORDS.length; i++) console.log(KEYWORDS[i] + "\t" + keywordFrequency[i]);
      }

      //-->
    </script>
  </head>
  <body onload="initPage()">
    <noscript>
      <div style="border: 8px solid fuchsia; background-color: aqua; color: navy; padding: 16px; font-size: 1.25em;">
        <p>This page requires JavaScript in order to function properly.  Either your browser does not support JavaScript, or JavaScript is disabled.  Please use a browser that supports JavaScript and make sure that JavaScript is enabled.</p>
        <p>With Internet Explorer, if you see a bar at the bottom of your browser like the one below, simply click <b><u>A</u>llow blocked content</b> and the page will reload with JavaScript enabled.  (If this bar has already disappeared by the time you get here, press Ctrl+R or F5 to reload the page, and it should reappear.)</p>
        <img src="../ie-blocked.png" alt="Internet Explorer restricted this webpage from running scripts or ActiveX controls.  (Allow blocked content)" style="display: block; margin: auto; width: 960px; height: 50px;" />
      </div>
    </noscript>
    <header>
      <b>Software by Jeff Bourdier</b>
      <nav>
        <a href="..">Home</a>
        <a href="../midiopsy">MIDIopsy</a>
        <a href="../plunge">Plunge</a>
        <a href="../dumprows"><span style="font-variant: small-caps;">DumpRows</span></a>
        <a href="../about">About</a>
      </nav>
    </header>
    <h1>Oracle cheat sheet</h1>
    <p>For pretty much my entire career as a <a href="https://en.wikipedia.org/wiki/Geographic_information_system">GIS</a> developer, I have worked with <a href="http://www.oracle.com/technetwork/database/index.html">Oracle Database</a>, and increasingly with <a href="http://www.oracle.com/technetwork/database/options/spatialandgraph/overview/index.html">Oracle Spatial</a> and <a href="http://www.oracle.com/technetwork/database/features/plsql/index.html">PL/SQL</a>.  As frequently as I find myself doing the same things repeatedly in Oracle, I find it very handy to have a "cheat sheet" such as this to remind me of syntax, object names, and so forth.  Links to Oracle documentation throughout this text are for version <a href="http://docs.oracle.com/cd/E11882_01/index.htm">11g Release 2 (11.2)</a>.</p>
    <h3>Oracle Database (general)</h3>
    <p>It's always good to know which version of Oracle you're dealing with, as there can be significant differences between versions.  Below are two different ways to get the Oracle Database version.</p>
    <pre>
SELECT * FROM PRODUCT_COMPONENT_VERSION;</pre>
    <table>
      <thead>
        <tr>
          <th>PRODUCT</th>
          <th>VERSION</th>
          <th>STATUS</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>NLSRTL </td>
          <td>11.2.0.4.0</td>
          <td>Production</td>
        </tr>
        <tr>
          <td>Oracle Database 11g Enterprise Edition </td>
          <td>11.2.0.4.0</td>
          <td>64bit Production</td>
        </tr>
        <tr>
          <td>PL/SQL </td>
          <td>11.2.0.4.0</td>
          <td>Production</td>
        </tr>
        <tr>
          <td>TNS for Solaris: </td>
          <td>11.2.0.4.0</td>
          <td>Production</td>
        </tr>
      </tbody>
    </table>
    <pre>
SELECT * FROM V$VERSION;</pre>
    <table>
      <thead>
        <tr>
          <th>BANNER</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production</td>
        </tr>
        <tr>
          <td>PL/SQL Release 11.2.0.4.0 - Production</td>
        </tr>
        <tr>
          <td>CORE	11.2.0.4.0	Production</td>
        </tr>
        <tr>
          <td>TNS for Solaris: Version 11.2.0.4.0 - Production</td>
        </tr>
        <tr>
          <td>NLSRTL Version 11.2.0.4.0 - Production</td>
        </tr>
      </tbody>
    </table>
    <p>There are at least four different ways to get the name of the database:</p>
    <ul>
      <li>from the <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_5127.htm">GLOBAL_NAME</a> data dictionary view,
      <pre>
SELECT * FROM GLOBAL_NAME;</pre>
      </li>
      <li>using the (undocumented) <code>ORA_DATABASE_NAME</code> event attribute function,
      <pre>
SELECT ORA_DATABASE_NAME FROM DUAL;</pre>
      </li>
      <li>from the <a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm">DB_NAME parameter of the USERENV namespace</a>,
      <pre>
SELECT SYS_CONTEXT('USERENV', 'DB_NAME') AS DB_NAME FROM DUAL;</pre>
      </li>
      <li>and from the <a href="http://docs.oracle.com/cd/E11882_01/server.112/e40402/dynviews_1097.htm">V$DATABASE</a> view (which can provide a lot more than just the database name).
      <pre>
SELECT "NAME" FROM V$DATABASE;</pre>
      </li>
    </ul>
    <p>The <a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions150.htm">REGEXP_SUBSTR</a> function can be used to "transpose" a comma-separated list to a recordset.</p>
    <pre>
SELECT TRIM(REGEXP_SUBSTR('One, Two, Three', '[^,]+', 1, LEVEL)) AS "VALUE"
FROM DUAL
CONNECT BY (REGEXP_SUBSTR('One, Two, Three', '[^,]+', 1, LEVEL) IS NOT NULL);</pre>
    <table>
      <thead>
        <tr>
          <th>VALUE</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>One</td>
        </tr>
        <tr>
          <td>Two</td>
        </tr>
        <tr>
          <td>Three</td>
        </tr>
      </tbody>
    </table>
    <h4>Data Dictionary Views</h4>
    <p>Most <a href="http://docs.oracle.com/cd/E11882_01/server.112/e40402/toc.htm">data dictionary views</a> have three versions, each of which begins with one of the following prefixes:</p>
    <ul>
      <li><code>USER_</code> - describes all objects of a given type <u>owned by the current user</u></li>
      <li><code>ALL_</code> - describes all objects of a given type <u>accessible to the current user</u></li>
      <li><code>DBA_</code> - describes all objects of a given type <u>in the database</u></li>
    </ul>
    <p>In most cases, each version of the views has the same set of fields, except that the <code>USER_</code> version does not have the <code>OWNER</code> field.  Some exceptions are noted below.</p>
    <ul>
      <li>USER_USERS shows only the current user, and <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_5081.htm">DBA_USERS</a> has many more fields than ALL_USERS.</li>
      <li>There is no USER_DIRECTORIES view; only <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_1078.htm">ALL_DIRECTORIES</a> and DBA_DIRECTORIES.</li>
      <li>There is no USER_ROLES or ALL_ROLES view; only <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_4220.htm">DBA_ROLES</a>.</li>
      <li>There is no ALL_ROLE_PRIVS view; only USER_ROLE_PRIVS and <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_4219.htm">DBA_ROLE_PRIVS</a>.  (USER_ROLE_PRIVS describes roles granted to the current user.)</li>
      <li>There is no ALL_SYS_PRIVS view; only USER_SYS_PRIVS and <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_5041.htm">DBA_SYS_PRIVS</a>.  (USER_SYS_PRIVS describes system privileges granted to the current user.)</li>
      <li>There is no ALL_FREE_SPACE view; only USER_FREE_SPACE and <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_3194.htm">DBA_FREE_SPACE</a>.</li>
    </ul>
    <p>(Several of the more commonly used data dictionary views and their more interesting fields are demonstrated by the <a href="https://github.com/jeffbourdier/dumprows/blob/main/templates/oracle.json">Oracle query template file</a> in the <a href="https://github.com/jeffbourdier/dumprows"><span style="font-variant: small-caps;">DumpRows</span></a> project.)</p>
    <p>The undocumented <a href="https://asktom.oracle.com/pls/apex/asktom.search?tag=all-probe-objects">SYS.ALL_PROBE_OBJECTS</a> view reports similar information to the <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40402/statviews_2009.htm">PLSQL_OBJECT_SETTINGS</a> data dictionary views (though the latter are probably more reliable).  If installed, it can be queried thus:</p>
    <pre>
SELECT OWNER, OBJECT_NAME, OBJECT_TYPE, CREATED, LAST_DDL_TIME
FROM SYS.ALL_PROBE_OBJECTS
WHERE (DEBUGINFO = 'T')
ORDER BY OWNER, OBJECT_TYPE, OBJECT_NAME;</pre>
    <p>Note some key differences between this and the <code>PLSQL_OBJECT_SETTINGS</code> views:</p>
    <ul>
      <li>The <code>SYS.</code> schema qualifier is required, as there is no public synonym for <code>ALL_PROBE_OBJECTS</code>.</li>
      <li><code>SYS.ALL_PROBE_OBJECTS</code> does not provide optimization level (whereas the <code>PLSQL_OBJECT_SETTINGS</code> views do).</li>
      <li><code>SYS.ALL_PROBE_OBJECTS</code> uses <code>'T'</code> and <code>'F'</code> (for <code>DEBUGINFO</code>), whereas the <code>PLSQL_OBJECT_SETTINGS</code> views use <code>'TRUE'</code> and <code>'FALSE'</code> (for <code>PLSQL_DEBUG</code>).</li>
    </ul>
    <p>More details about PL/SQL debug settings are given in the <b>Debug Settings</b> section (under <b>PL/SQL</b>, below).</p>
    <p>While <code>DBA_VIEWS.TEXT</code>, <code>DBA_MVIEWS."QUERY"</code>, <code>DBA_TRIGGERS.TRIGGER_BODY</code>, and <code>DBA_SOURCE.TEXT</code> can be used to get the DDL of a view, materialized view, trigger, or package/procedure/function/trigger/type (respectively); the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_metada.htm#ARPLS66885">DBMS_METADATA.GET_DDL</a> function can be used to get the DDL of any object.</p>
    <pre>
SELECT DBMS_METADATA.GET_DDL(OBJECT_TYPE, OBJECT_NAME, OWNER) AS TEXT
FROM (SELECT * FROM DBA_OBJECTS WHERE (OBJECT_NAME = 'name'));</pre>
    <p>The following query is useful for displaying column definitions as in a <a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm">CREATE TABLE</a> statement (and is also a good demonstration of the <a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm">CASE</a> expression).</p>
    <pre>
SELECT
  COLUMN_NAME,
  CASE
    WHEN (CHAR_LENGTH > 0)
    THEN DATA_TYPE || '(' || CHAR_LENGTH || ')'
    WHEN (DATA_PRECISION IS NULL)
    THEN CASE WHEN (DATA_SCALE IS NULL) THEN DATA_TYPE ELSE 'INTEGER' END
    ELSE
      DATA_TYPE || '(' || DATA_PRECISION ||
      CASE WHEN (DATA_SCALE > 0) THEN ',' || DATA_SCALE END || ')'
  END AS DATATYPE
FROM DBA_TAB_COLUMNS
WHERE (TABLE_NAME = 'table')
ORDER BY COLUMN_ID;</pre>
    <p>And speaking of...</p>
    <h4>Table Management</h4>
    <p>The following example goes through the process of creating and altering tables, illustrating the following concepts:</p>
    <ul>
      <li>default value</li>
      <li>primary key constraint</li>
      <li>foreign key constraint</li>
      <li>check constraint</li>
      <li>adding a field</li>
      <li>modifying a field</li>
      <li>dropping a field</li>
      <li>creating a trigger</li>
    </ul>
    <p>We'll start by creating two tables: one for artists, and another for albums released by those artists.  In these tables:</p>
    <ul>
      <li><code>ARTIST</code> has a single primary key field (also called <code>ARTIST</code>).</li>
      <li><code>ALBUM</code> has a composite primary key (consisting of both the <code>ARTIST</code> and <code>TITLE</code> fields), so it must be defined out-of-line.</li>
      <li><code>ALBUM.ARTIST</code> is a foreign key that references the <code>ARTIST</code> table (and since we did not specify a field, this foreign key implicitly references the primary key field of the <code>ARTIST</code> table).</li>
      <li><code>ALBUM</code> has a check constraint to ensure that <code>RELEASE_YEAR</code> is between <code>1</code> and <code>9999</code>.</li>
    </ul>
    <pre>
CREATE TABLE ARTIST (ARTIST VARCHAR2(50) PRIMARY KEY);

CREATE TABLE ALBUM
(
  ARTIST VARCHAR2(50) REFERENCES ARTIST,
  TITLE VARCHAR2(100),
  RELEASE_YEAR INTEGER CHECK (RELEASE_YEAR BETWEEN 1 AND 9999),
  PRIMARY KEY (ARTIST, TITLE)
);</pre>
    <p>Note that above, the constraints are defined without names, which means that Oracle generates a cryptic name (like <code>SYS_C0062877</code>) for each of them.  If the constraints are to be referred to programatically, it is probably better to name them.  Below are the same two <code>CREATE TABLE</code> statements with names given to the constraints.</p>
    <pre>
CREATE TABLE ARTIST (ARTIST VARCHAR2(50) CONSTRAINT ARTIST_PKC PRIMARY KEY);

CREATE TABLE ALBUM
(
  ARTIST VARCHAR2(50) CONSTRAINT ALBUM_ARTIST_FKC REFERENCES ARTIST,
  TITLE VARCHAR2(100),
  RELEASE_YEAR INTEGER
    CONSTRAINT ALBUM_RELEASE_YEAR_CKC CHECK (RELEASE_YEAR BETWEEN 1 AND 9999),
  CONSTRAINT ALBUM_PKC PRIMARY KEY (ARTIST, TITLE)
);</pre>
    <p>Suppose you decide it makes more sense for <code>ALBUM.RELEASE_YEAR</code> to be a number with a precision (maximum number of significant digits) of <code>4</code>, rather than an ANSI integer with a check constraint:</p>
    <pre>
ALTER TABLE ALBUM MODIFY (RELEASE_YEAR NUMBER(4));</pre>
    <p>Say you also want to store the genre of each album, so you create a new <code>GENRE</code> table and modify <code>ALBUM</code> as follows:</p>
    <pre>
CREATE TABLE GENRE
(
  GENRE VARCHAR2(25)
    CONSTRAINT GENRE_PKC PRIMARY KEY
    CONSTRAINT GENRE_CKC CHECK (GENRE = UPPER(TRIM(GENRE)))
);

ALTER TABLE ALBUM ADD
(
  GENRE VARCHAR2(25) DEFAULT 'ROCK'
    CONSTRAINT ALBUM_GENRE_FKC REFERENCES GENRE,
  NOTES VARCHAR2(100)
);</pre>
    <p>The syntax of each column definition is essentially the same as in a <code>CREATE TABLE</code> statement.  Note here that the <code>GENRE</code> value of all records in the <code>GENRE</code> table must be uppercase (and have no leading or trailing spaces), and <code>ALBUM.GENRE</code> has a default value of <code>'ROCK'</code> (which means that the <code>GENRE</code> table must have a record with a <code>GENRE</code> value of <code>'ROCK'</code>).</p>
    <p>Now let's say you want to track whether or not each artist is still living.</p>
    <pre>
ALTER TABLE ARTIST ADD (ALIVE CHAR(1) CHECK (ALIVE IN ('Y', 'N')));</pre>
    <p>On second thought, never mind, that was a silly idea.  Who cares if the artist is <a style="text-decoration: none; color: inherit;" href="https://www.youtube.com/watch?v=PGNiXGX2nLU">dead or alive</a>?</p>
    <pre>
ALTER TABLE ARTIST DROP COLUMN ALIVE;</pre>
    <p>Note the above syntax works only for single fields.  The following syntax could also have been used (multiple fields would be comma-separated).</p>
    <pre>
ALTER TABLE ARTIST DROP (ALIVE);</pre>
    <p>If you want to be able to insert an <code>ALBUM</code> record with a new genre without first having to insert a new <code>GENRE</code> record, you could automate this by <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/create_trigger.htm">creating a trigger</a> on the <code>ALBUM</code> table to insert the new <code>GENRE</code> record for you.</p>
    <pre>
CREATE TRIGGER ALBUM_GENRE_TRIGGER
BEFORE INSERT OR UPDATE ON ALBUM
FOR EACH ROW
WHEN (NEW.GENRE IS NOT NULL)
DECLARE
  n PLS_INTEGER;
  s VARCHAR2(32);
BEGIN
  /* If no other genre like this one already exists, add it to the list. */
  SELECT COUNT(*) INTO n FROM GENRE WHERE (GENRE = UPPER(TRIM(:NEW.GENRE)));
  IF (n &lt; 1) THEN
    INSERT INTO GENRE VALUES (UPPER(TRIM(:NEW.GENRE)));
    :NEW.GENRE := UPPER(TRIM(:NEW.GENRE));
    RETURN;
  END IF;

  /* Since there is already a genre like this one, use the existing one. */
  SELECT GENRE INTO s FROM GENRE WHERE (GENRE = UPPER(TRIM(:NEW.GENRE)));
  :NEW.GENRE := s;
END;
/</pre>
    <h3>Oracle Spatial</h3>
    <p>It's always good to know which version of Oracle Spatial you're dealing with, as there can be significant differences between versions.</p>
    <pre>
SELECT SDO_VERSION FROM DUAL;</pre>
    <table>
      <thead>
        <tr>
          <th>SDO_VERSION</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>11.2.0.4.0</td>
        </tr>
      </tbody>
    </table>
    <p>Here's a breakdown of the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_objrelschema.htm#SPATL489">SDO_GEOMETRY</a> object type:</p>
    <table>
      <thead>
        <tr>
          <th>Attribute</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody style="font-size: 0.8em;">
        <tr>
          <td style="font-size: 0.8em;">SDO_GTYPE</td>
          <td style="font-size: 0.8em;">NUMBER</td>
          <td>A 4-digit number in the form <i>DLTT</i>, where:
            <ul>
              <li>
                <i>D</i> = number of dimensions (2, 3, or 4)
              </li>
              <li>
                <i>L</i> = linear referencing measure dimension (0, 3, or 4)
              </li>
              <li>
                <i>TT</i> = geometry type
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td style="font-size: 0.8em;">SDO_SRID</td>
          <td style="font-size: 0.8em;">NUMBER</td>
          <td>Spatial Reference Identifier (see <b>SRIDs</b>, below)</td>
        </tr>
        <tr>
          <td style="font-size: 0.8em;">SDO_POINT</td>
          <td style="font-size: 0.8em;">SDO_POINT_TYPE</td>
          <td>Can be used for optimal storage of point geometries (rarely used in practice)</td>
        </tr>
        <tr>
          <td style="font-size: 0.8em;">SDO_ELEM_INFO</td>
          <td style="font-size: 0.8em;">SDO_ELEM_INFO_ARRAY</td>
          <td>Specifies how to interpret ordinates.  Typically, one set of 3 numbers, as described below.  (For compound elements, there is an additional set for each subelement.)
            <ul>
              <li>Starting offset (typically 1)</li>
              <li>Element type (see below)</li>
              <li>Interpretation (depends on element type; see below)</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td style="font-size: 0.8em;">SDO_ORDINATES</td>
          <td style="font-size: 0.8em;">SDO_ORDINATE_ARRAY</td>
          <td>Ordinates (whose interpretation depends on <code>SDO_ELEM_INFO</code>)</td>
        </tr>
      </tbody>
    </table>
    <p>Common <code>SDO_GTYPE</code> values:</p>
    <table>
      <thead>
        <tr>
          <th>Value</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2001</td>
          <td>2-dimensional point with no linear referencing</td>
        </tr>
        <tr>
          <td>2002</td>
          <td>2-dimensional line string with no linear referencing</td>
        </tr>
        <tr>
          <td>2003</td>
          <td>2-dimensional polygon (with no linear referencing)</td>
        </tr>
      </tbody>
    </table>
    <p>Common element type values and corresponding interpretations (from <code>SDO_ELEM_INFO</code>, above):</p>
    <table>
      <thead>
        <tr>
          <th>Value</th>
          <th>Description</th>
          <th>Interpretation (3rd number in set)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>Point (or orientation for an oriented point)</td>
          <td>
            <ul>
              <li>1 = point ordinates</li>
              <li>0 = point orientation ordinates</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td>Line string</td>
          <td>
            <ul>
              <li>1 = vertexes connected by straight line segments</li>
              <li>2 = a connected sequence of circular arcs</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>1003</td>
          <td>Exterior polygon ring (counterclockwise)</td>
          <td>
            <ul>
              <li>1 = vertexes connected by straight line segments</li>
              <li>2 = a connected sequence of circular arcs</li>
              <li>3 = rectangle</li>
              <li>4 = circle</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <p>Here's how to construct an <code>SDO_GEOMETRY</code> object:</p>
    <pre>
SELECT
  MDSYS.SDO_GEOMETRY(
    2003,  /* 2-dimensional polygon */
    srid,  /* projected coordinate system */
    NULL,  /* not using optimal point storage */
    MDSYS.SDO_ELEM_INFO_ARRAY(1, 1003, 4),  /* exterior polygon ring, circle */
    MDSYS.SDO_ORDINATE_ARRAY(
      center_x, center_y + radius,
      center_x + radius, center_y,
      center_x, center_y - radius)) AS SHAPE
FROM DUAL;</pre>
    <p>This would create a circle.  Note:</p>
    <ul>
      <li>The ordinates are "three distinct non-colinear points, all on the circumference of the circle" (see <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_objrelschema.htm#BGHDGCCE">Values and Semantics in SDO_ELEM_INFO</a>).</li>
      <li><a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_cs_concepts.htm#SPATL624">According to Oracle</a>, a circle cannot be created using a geodetic coordinate system; hence, the <code>SRID</code> must reference a projected coordinate system.</li>
      <li>The function <code>CREATE_CIRCLE</code> (under <b>PL/SQL</b>, below) shows how to do this programatically.</li>
    </ul>
    <p>The <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_util.htm#SPATL1237">SDO_UTIL.GETVERTICES</a> function is very useful for examining the coordinates of a geometry.</p>
    <pre>
SELECT GV."ID", GV.X, GV.Y
FROM table, TABLE(SDO_UTIL.GETVERTICES(field)) GV
WHERE (condition)
ORDER BY GV."ID";</pre>
    <p>This is how Oracle recommends to validate spatial geometries.</p>
    <pre>
SELECT
  table.ROWID,
  SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(table.field, GM.SDO_DIMINFO) AS VALID
FROM
  schema.table,
  (
    SELECT SDO_DIMINFO
    FROM MDSYS.SDO_GEOM_METADATA_TABLE
    WHERE (SDO_OWNER = 'schema') AND (SDO_TABLE_NAME = 'table')
  ) GM;</pre>
    <h4>Spatialization</h4>
    <p>If a table has an <code>SDO_GEOMETRY</code> field, the following steps can be used to "spatialize" it so that it can be used by Oracle Spatial and other software.</p>
    <p>Determine the extents of the geometry.</p>
    <pre>
SELECT MIN(X), MAX(X), MIN(Y), MAX(Y)
FROM table, TABLE(SDO_UTIL.GETVERTICES(field));</pre>
    <p>To add a 5% buffer at each boundary (to allow for potential expansion):</p>
    <pre>
SELECT
  (MIN_X - DX) AS MIN_X1, (MAX_X + DX) AS MAX_X1,
  (MIN_Y - DY) AS MIN_Y1, (MAX_Y + DY) AS MAX_Y1
FROM
  (
    SELECT
      MIN_X, MAX_X, (0.05 * (MAX_X - MIN_X)) AS DX,
      MIN_Y, MAX_Y, (0.05 * (MAX_Y - MIN_Y)) AS DY
    FROM
    (
      SELECT
        MIN(X) AS MIN_X, MAX(X) AS MAX_X,
        MIN(Y) AS MIN_Y, MAX(Y) AS MAX_Y
      FROM table, TABLE(SDO_UTIL.GETVERTICES(field))
    )
  );</pre>
    <p>Insert a record into <code>MDSYS.SDO_GEOM_METADATA_TABLE</code>.</p>
    <pre>
INSERT INTO MDSYS.SDO_GEOM_METADATA_TABLE
VALUES
(
  'schema',
  'table',
  'field',
  SDO_DIM_ARRAY
  (
    SDO_DIM_ELEMENT('X', min_x, max_x, 0.05),
    SDO_DIM_ELEMENT('Y', min_y, max_y, 0.05)
  ),
  srid
);</pre>
    <p>Create a spatial index on the <code>SDO_GEOMETRY</code> field.</p>
    <pre>
CREATE INDEX index ON table(field) INDEXTYPE IS MDSYS.SPATIAL_INDEX;</pre>
    <h4>SRIDs</h4>
    <p><a href="http://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_objrelschema.htm#SPATL492">According to Oracle</a>: "All geometries in a geometry column must have the same SDO_SRID value if a spatial index will be built on that column."  Oracle stores spatial reference systems (identified by <code>SRID</code>) in the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_cs_concepts.htm#SPATL652">SDO_COORD_REF_SYS</a> table.  This table includes many well-known <a href="http://www.epsg.org/">EPSG</a> SRIDs, as well as some that are specific to Oracle (most of which can be thought of as Oracle-specific versions of their EPSG counterparts).  For example, the following EPSG SRIDs, along with their Oracle-specific equivalents, can be found in the table.</p>
    <pre>
SELECT SRID, COORD_REF_SYS_NAME,
  CASE WHEN (IS_LEGACY = 'TRUE') THEN INFORMATION_SOURCE ELSE DATA_SOURCE
  END AS "SOURCE"
FROM SDO_COORD_REF_SYS
WHERE (SRID IN (4269, 4326, 8265, 8307))
ORDER BY SRID;</pre>
    <table>
      <thead>
        <tr>
          <th>SRID</th>
          <th>COORD_REF_SYS_NAME</th>
          <th>SOURCE</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>4269</td>
          <td>NAD83</td>
          <td>EPSG</td>
        </tr>
        <tr>
          <td>4326</td>
          <td>WGS 84</td>
          <td>EPSG</td>
        </tr>
        <tr>
          <td>8265</td>
          <td>Longitude / Latitude (NAD 83)</td>
          <td>Oracle</td>
        </tr>
        <tr>
          <td>8307</td>
          <td>Longitude / Latitude (WGS 84)</td>
          <td>Oracle</td>
        </tr>
      </tbody>
    </table>
    <p>Note that Oracle does not store the <a href="https://www.esri.com/en-us/home">ESRI</a> SRIDs for <a href="https://www.ngs.noaa.gov/TOOLS/spc.shtml">State Plane Coordinate System (SPCS)</a> spatial references.  For example, if we try to look up the three SRIDs for the Texas South Central Zone (FIPS 4204, in feet), we get results for the <a href="https://epsg.io/2278">EPSG SRID (2278)</a> and its Oracle-specific equivalent (41153), but not the <a href="https://epsg.io/102740">ESRI SRID (102740)</a>.</p>
    <pre>
SELECT SRID, COORD_REF_SYS_NAME,
  CASE WHEN (IS_LEGACY = 'TRUE') THEN INFORMATION_SOURCE ELSE DATA_SOURCE
  END AS "SOURCE"
FROM SDO_COORD_REF_SYS
WHERE (SRID IN (2278, 41153, 102740))
ORDER BY SRID;</pre>
    <table>
      <thead>
        <tr>
          <th>SRID</th>
          <th>COORD_REF_SYS_NAME</th>
          <th>SOURCE</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2278</td>
          <td>NAD83 / Texas South Central (ftUS)</td>
          <td>EPSG</td>
        </tr>
        <tr>
          <td>41153</td>
          <td>Texas 4204, South Central Zone (1983, US Survey feet)</td>
          <td>Oracle</td>
        </tr>
      </tbody>
    </table>
    <p>Data on units can be found by joining with the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_cs_concepts.htm#SPATL636">SDO_COORD_AXES</a> and <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e11830/sdo_cs_concepts.htm#SPATL687">SDO_UNITS_OF_MEASURE</a> tables.</p>
    <pre>
SELECT
  RS.SRID, RS.COORD_REF_SYS_NAME AS "NAME", RS.COORD_REF_SYS_KIND AS KIND,
  AU.AXES, AU.UNIT_OF_MEAS_TYPE AS UOM_TYPE, AU.UNIT_OF_MEAS_NAME AS UOM_NAME
FROM
  (
    SELECT SRID, COORD_REF_SYS_NAME, COORD_REF_SYS_KIND, COORD_SYS_ID
    FROM SDO_COORD_REF_SYS
    WHERE (SRID IN (2278, 3857, 4269, 4326, 32615))
  ) RS
  INNER JOIN
  (
    SELECT
      SDO_COORD_AXES.COORD_SYS_ID,
      (
        LISTAGG(SDO_COORD_AXES.COORD_AXIS_ABBREVIATION, ', ')
        WITHIN GROUP (ORDER BY COORD_AXIS_ABBREVIATION)
      ) AS AXES,
      SDO_UNITS_OF_MEASURE.UNIT_OF_MEAS_TYPE,
      SDO_UNITS_OF_MEASURE.UNIT_OF_MEAS_NAME
    FROM
      SDO_COORD_AXES
      INNER JOIN SDO_UNITS_OF_MEASURE
      ON (SDO_COORD_AXES.UOM_ID = SDO_UNITS_OF_MEASURE.UOM_ID)
    GROUP BY
      SDO_COORD_AXES.COORD_SYS_ID,
      SDO_UNITS_OF_MEASURE.UNIT_OF_MEAS_TYPE,
      SDO_UNITS_OF_MEASURE.UNIT_OF_MEAS_NAME
  ) AU
  ON (RS.COORD_SYS_ID = AU.COORD_SYS_ID)
ORDER BY RS.COORD_REF_SYS_KIND, RS.SRID;</pre>
    <table>
      <thead style="font-size: 0.8em;">
        <tr>
          <th>SRID</th>
          <th>NAME</th>
          <th>KIND</th>
          <th>AXES</th>
          <th>UOM_TYPE</th>
          <th>UOM_NAME</th>
        </tr>
      </thead>
      <tbody style="font-size: 0.8em;">
        <tr>
          <td>4269</td>
          <td>NAD83</td>
          <td style="font-size: 0.8em;">GEOGRAPHIC2D</td>
          <td>Lat, Long</td>
          <td>angle</td>
          <td>degree (supplier to define representation)</td>
        </tr>
        <tr>
          <td>4326</td>
          <td>WGS 84</td>
          <td style="font-size: 0.8em;">GEOGRAPHIC2D</td>
          <td>Lat, Long</td>
          <td>angle</td>
          <td>degree (supplier to define representation)</td>
        </tr>
        <tr>
          <td>2278</td>
          <td>NAD83 / Texas South Central (ftUS)</td>
          <td style="font-size: 0.8em;">PROJECTED</td>
          <td>X, Y</td>
          <td>length</td>
          <td>US survey foot</td>
        </tr>
        <tr>
          <td>3857</td>
          <td>WGS 84 / Pseudo-Mercator</td>
          <td style="font-size: 0.8em;">PROJECTED</td>
          <td>X, Y</td>
          <td>length</td>
          <td>metre</td>
        </tr>
        <tr>
          <td>32615</td>
          <td>WGS 84 / UTM zone 15N</td>
          <td style="font-size: 0.8em;">PROJECTED</td>
          <td>E, N</td>
          <td>length</td>
          <td>metre</td>
        </tr>
      </tbody>
    </table>
    <h3>PL/SQL</h3>
    <p><a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/datatypes.htm#LNPLS319">PLS_INTEGER</a> is the recommended integral data type, as long as the value can be stored in 32 bits.  Below are some examples of operations with <code>PLS_INTEGER</code>, including division and the <a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm">FLOOR</a> and <a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions024.htm">CEIL</a> functions.</p>
    <pre>
DECLARE
  n PLS_INTEGER;
BEGIN
  n := 400 / 400;
  DBMS_OUTPUT.PUT_LINE('400 / 400 = ' || n);

  n := CEIL(400 / 400);
  DBMS_OUTPUT.PUT_LINE('CEIL(400 / 400) = ' || n);

  n := 401 / 400;
  DBMS_OUTPUT.PUT_LINE('401 / 400 = ' || n);

  n := CEIL(401 / 400);
  DBMS_OUTPUT.PUT_LINE('CEIL(401 / 400) = ' || n);

  n := 599 / 400;
  DBMS_OUTPUT.PUT_LINE('599 / 400 = ' || n);

  n := CEIL(599 / 400);
  DBMS_OUTPUT.PUT_LINE('CEIL(599 / 400) = ' || n);

  n := 600 / 400;
  DBMS_OUTPUT.PUT_LINE('600 / 400 = ' || n);

  n := FLOOR(600 / 400);
  DBMS_OUTPUT.PUT_LINE('FLOOR(600 / 400) = ' || n);

  n := 799 / 400;
  DBMS_OUTPUT.PUT_LINE('799 / 400 = ' || n);

  n := FLOOR(799 / 400);
  DBMS_OUTPUT.PUT_LINE('FLOOR(799 / 400) = ' || n);

  n := 800 / 400;
  DBMS_OUTPUT.PUT_LINE('800 / 400 = ' || n);
END;
/

/* Output:
 *
 * 400 / 400 = 1
 * CEIL(400 / 400) = 1
 * 401 / 400 = 1
 * CEIL(401 / 400) = 2
 * 599 / 400 = 1
 * CEIL(599 / 400) = 2
 * 600 / 400 = 2
 * FLOOR(600 / 400) = 1
 * 799 / 400 = 2
 * FLOOR(799 / 400) = 1
 * 800 / 400 = 2
 */</pre>
    <p>Below is a demonstration of the <code>BOOLEAN</code> data type.</p>
    <pre>
DECLARE
  bt BOOLEAN;
  bf BOOLEAN;
  bn BOOLEAN;
BEGIN
  bt := TRUE;
  bf := FALSE;
  bn := NULL;

  IF bt THEN DBMS_OUTPUT.PUT_LINE('bt'); END IF;
  IF bf THEN DBMS_OUTPUT.PUT_LINE('bf'); END IF;
  IF bn THEN DBMS_OUTPUT.PUT_LINE('bn'); END IF;

  IF NOT bt THEN DBMS_OUTPUT.PUT_LINE('NOT bt'); END IF;
  IF NOT bf THEN DBMS_OUTPUT.PUT_LINE('NOT bf'); END IF;
  IF NOT bn THEN DBMS_OUTPUT.PUT_LINE('NOT bn'); END IF;

  IF bt IS NULL THEN DBMS_OUTPUT.PUT_LINE('bt IS NULL'); END IF;
  IF bf IS NULL THEN DBMS_OUTPUT.PUT_LINE('bf IS NULL'); END IF;
  IF bn IS NULL THEN DBMS_OUTPUT.PUT_LINE('bn IS NULL'); END IF;
END;
/

/* Output:
 *
 * bt
 * NOT bf
 * bn IS NULL
 */</pre>
    <p>Below is a demonstration of <a href="https://tools.ietf.org/html/rfc4122">GUID/UUID</a> processing.</p>
    <pre>
DECLARE
  s_guid RAW(32);
  f_guid CHAR(38);
BEGIN
  /* Generate a "raw" system GUID. */
  s_guid := SYS_GUID();

  /* Format it for user-friendly display. */
  f_guid := '{' ||
    SUBSTR(s_guid, 1, 8) || '-' ||
    SUBSTR(s_guid, 9, 4) || '-' ||
    SUBSTR(s_guid, 13, 4) || '-' ||
    SUBSTR(s_guid, 17, 4) || '-' ||
    SUBSTR(s_guid, 21, 12) || '}';
END;
/</pre>
    <p>Below are a few different ways to use the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/tuning.htm#LNPLS891">BULK COLLECT</a> clause to retrieve a list of roles granted to the current user.</p>
    <pre>
DECLARE
  TYPE ROLE_TABLE IS TABLE OF USER_ROLE_PRIVS%ROWTYPE;
  role_records ROLE_TABLE;
BEGIN
  SELECT *
  BULK COLLECT INTO role_records
  FROM USER_ROLE_PRIVS
  ORDER BY GRANTED_ROLE;

  FOR i IN role_records.FIRST .. role_records.LAST LOOP
    DBMS_OUTPUT.PUT_LINE(role_records(i).GRANTED_ROLE);
  END LOOP;
END;
/</pre>
    <pre>
DECLARE
  CURSOR ROLE_CURSOR IS SELECT GRANTED_ROLE FROM USER_ROLE_PRIVS;
  TYPE ROLE_TABLE IS TABLE OF ROLE_CURSOR%ROWTYPE;
  role_records ROLE_TABLE;
BEGIN
  SELECT GRANTED_ROLE
  BULK COLLECT INTO role_records
  FROM USER_ROLE_PRIVS
  ORDER BY GRANTED_ROLE;

  FOR i IN role_records.FIRST .. role_records.LAST LOOP
    DBMS_OUTPUT.PUT_LINE(role_records(i).GRANTED_ROLE);
  END LOOP;
END;
/</pre>
    <pre>
DECLARE
  TYPE ROLE_TABLE IS TABLE OF USER_ROLE_PRIVS.GRANTED_ROLE%TYPE;
  role_records ROLE_TABLE;
BEGIN
  SELECT GRANTED_ROLE
  BULK COLLECT INTO role_records
  FROM USER_ROLE_PRIVS
  ORDER BY GRANTED_ROLE;

  FOR i IN role_records.FIRST .. role_records.LAST LOOP
    DBMS_OUTPUT.PUT_LINE(role_records(i));
  END LOOP;
END;
/</pre>
    <p>Building on the previous example, the following shows how to pass a table as an argument to a procedure in order to determine which object privileges are granted to the current user (including those granted through roles, up to 3 levels deep).</p>
    <pre>
/* This is necessary in order to use the collection type in SQL (below). */
CREATE TYPE NAME_TABLE IS TABLE OF VARCHAR2(30);
/

DECLARE
  TYPE PRIV_TABLE IS TABLE OF DBA_TAB_PRIVS%ROWTYPE;

  s VARCHAR2(128);
  names0 NAME_TABLE;
  names1 NAME_TABLE;
  names2 NAME_TABLE;
  privs PRIV_TABLE;

  PROCEDURE GET_OBJ_PRIVS(
    grantees IN NAME_TABLE,
    obj_privs IN OUT NOCOPY PRIV_TABLE
  ) IS
  BEGIN
    SELECT *
    BULK COLLECT INTO obj_privs
    FROM DBA_TAB_PRIVS
    WHERE (GRANTEE IN (SELECT * FROM TABLE(grantees)))
    ORDER BY OWNER, TABLE_NAME, "PRIVILEGE";
  END;

  PROCEDURE GET_ROLES(
    grantees IN NAME_TABLE,
    granted_roles IN OUT NOCOPY NAME_TABLE
  ) IS
  BEGIN
    SELECT DISTINCT GRANTED_ROLE
    BULK COLLECT INTO granted_roles
    FROM DBA_ROLE_PRIVS
    WHERE (GRANTEE IN (SELECT * FROM TABLE(grantees)))
    ORDER BY GRANTED_ROLE;
  END;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Object privileges granted directly:');
  FOR r IN
  (
    SELECT DISTINCT OWNER, TABLE_NAME, "PRIVILEGE"
    FROM USER_TAB_PRIVS
    ORDER BY OWNER, TABLE_NAME, "PRIVILEGE"
  ) LOOP
    s := r."PRIVILEGE" || ' on ' || r.OWNER || '.' || r.TABLE_NAME;
    DBMS_OUTPUT.PUT_LINE(s);
    END LOOP;
  DBMS_OUTPUT.PUT_LINE(' ');

  DBMS_OUTPUT.PUT_LINE('Roles granted directly (level 0):');
  SELECT GRANTED_ROLE BULK COLLECT INTO names0 FROM USER_ROLE_PRIVS ORDER BY GRANTED_ROLE;
  FOR i IN 1 .. names0.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE(names0(i));
  END LOOP;
  DBMS_OUTPUT.PUT_LINE(' ');

  DBMS_OUTPUT.PUT_LINE('Object privileges granted through those roles:');
  GET_OBJ_PRIVS(names0, privs);
  FOR i IN 1 .. privs.COUNT LOOP
    s := privs(i)."PRIVILEGE" || ' on ' || privs(i).OWNER || '.' || privs(i).TABLE_NAME;
    DBMS_OUTPUT.PUT_LINE(s);
  END LOOP;
  DBMS_OUTPUT.PUT_LINE(' ');

  DBMS_OUTPUT.PUT_LINE('Roles granted through those roles (level 1):');
  GET_ROLES(names0, names1);
  FOR i IN 1 .. names1.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE(names1(i));
  END LOOP;
  DBMS_OUTPUT.PUT_LINE(' ');

  DBMS_OUTPUT.PUT_LINE('Object privileges granted through those roles:');
  GET_OBJ_PRIVS(names1, privs);
  FOR i IN 1 .. privs.COUNT LOOP
    s := privs(i)."PRIVILEGE" || ' on ' || privs(i).OWNER || '.' || privs(i).TABLE_NAME;
    DBMS_OUTPUT.PUT_LINE(s);
  END LOOP;
  DBMS_OUTPUT.PUT_LINE(' ');

  DBMS_OUTPUT.PUT_LINE('Roles granted through those roles (level 2):');
  GET_ROLES(names1, names2);
  FOR i IN 1 .. names2.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE(names2(i));
  END LOOP;
  DBMS_OUTPUT.PUT_LINE(' ');

  DBMS_OUTPUT.PUT_LINE('Object privileges granted through those roles:');
  GET_OBJ_PRIVS(names2, privs);
  FOR i IN 1 .. privs.COUNT LOOP
    s := privs(i)."PRIVILEGE" || ' on ' || privs(i).OWNER || '.' || privs(i).TABLE_NAME;
    DBMS_OUTPUT.PUT_LINE(s);
  END LOOP;
END;
/</pre>
    <p>The following function demonstrates:</p>
    <ul>
      <li>how to build an <code>SDO_GEOMETRY</code> object programatically</li>
      <li>how to write text output to a file on the database server using the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/u_file.htm">UTL_FILE</a> package</li>
      <li>error handling for user-defined exceptions (using the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/errors.htm#LNPLS99960">RAISE_APPLICATION_ERROR</a> procedure)</li>
      <li>error handling for internally defined exceptions (using the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/sqlerrm_function.htm">SQLERRM</a> and <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_util.htm#ARPLS73241">DBMS_UTILITY.FORMAT_ERROR_BACKTRACE</a> functions)</li>
    </ul>
    <pre>
CREATE OR REPLACE FUNCTION CREATE_CIRCLE(
  crsid IN INTEGER,
  center_x IN NUMBER,
  center_y IN NUMBER,
  radius IN NUMBER
) RETURN SDO_GEOMETRY IS
  s VARCHAR2(512);
  geodetic_crs EXCEPTION;
  elem_info SDO_ELEM_INFO_ARRAY;
  ordinates SDO_ORDINATE_ARRAY;
  center NUMBER;
  sign_type SIGNTYPE;
  file_handle UTL_FILE.FILE_TYPE;
BEGIN
  /* If the SRID identifies a geodetic coordinate system, raise an error. */
  SELECT COORD_REF_SYS_KIND INTO s FROM SDO_COORD_REF_SYS WHERE (SRID = crsid);
  IF (s LIKE 'GEOGRAPHIC%') THEN RAISE geodetic_crs; END IF;

  /* Build the SDO_ELEM_INFO attribute (circular exterior polygon ring). */
  elem_info := SDO_ELEM_INFO_ARRAY();
  elem_info.EXTEND(3);
  elem_info(1) := 1;
  elem_info(2) := 1003;
  elem_info(3) := 4;

  /* Build the SDO_ORDINATES attribute (three
   * points on the circumference of the circle).
   */
  ordinates := SDO_ORDINATE_ARRAY();
  FOR i IN 1 .. 6 LOOP
    ordinates.EXTEND(1);
    IF (BITAND(i, 1) > 0) THEN
      center := center_x;
    ELSE
      center := center_y;
    END IF;
    sign_type := SIGN(BITAND(i, 2) - BITAND(i, 6));
    ordinates(i) := center + (sign_type * radius);
  END LOOP;

  /* Construct and return the SDO_GEOMETRY object. */
  RETURN SDO_GEOMETRY(2003, crsid, NULL, elem_info, ordinates);
EXCEPTION
  WHEN geodetic_crs THEN
    RAISE_APPLICATION_ERROR(-20001, 'Coordinate system cannot be geodetic.');
  WHEN OTHERS THEN
    /* Open a text file in "append text" mode.  (Note: LOG_DIR is a
     * directory object that must appear in the ALL_DIRECTORIES view.)
     */
    file_handle := UTL_FILE.FOPEN('LOG_DIR', 'error.log', 'a');
    s := SQLERRM;
    UTL_FILE.PUT_LINE(file_handle, s);
    UTL_FILE.PUT_LINE(file_handle, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
    UTL_FILE.FCLOSE(file_handle);
END;
/</pre>
    <p>The following procedure demonstrates how to send an email using the <a href="https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/u_smtp.htm">UTL_SMTP</a> package.</p>
    <pre>
CREATE OR REPLACE PROCEDURE SEND_EMAIL(
  domain IN VARCHAR2,
  sender IN VARCHAR2,
  recipient IN VARCHAR2,
  subject IN VARCHAR2,
  message IN VARCHAR2,
  sender_name IN VARCHAR2 DEFAULT NULL,
  recipient_name IN VARCHAR2 DEFAULT NULL
) IS
  cn UTL_SMTP.CONNECTION;
  from_name VARCHAR2(64);
  to_name VARCHAR2(64);
BEGIN
  /* Initiate the mail transaction. */
  cn := UTL_SMTP.OPEN_CONNECTION('mail.' || domain);
  UTL_SMTP.HELO(cn, domain);
  UTL_SMTP.MAIL(cn, sender);
  UTL_SMTP.RCPT(cn, recipient);

  /* Determine "From" and "To" names. */
  IF (sender_name IS NULL) THEN
    from_name := sender;
  ELSE
    from_name := sender_name;
  END IF;
  IF (recipient_name IS NULL) THEN
    to_name := recipient;
  ELSE
    to_name := recipient_name;
  END IF;

  /* Write the message. */
  UTL_SMTP.OPEN_DATA(cn);
  UTL_SMTP.WRITE_DATA(cn, 'From: ' || from_name || UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(cn, 'To: ' || to_name || UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(cn, 'Subject: ' || subject || UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(cn, UTL_TCP.CRLF);
  UTL_SMTP.WRITE_DATA(cn, message || UTL_TCP.CRLF);

  /* End the transaction. */
  UTL_SMTP.CLOSE_DATA(cn);
  UTL_SMTP.QUIT(cn);
END;
/</pre>
    <h4>Debug Settings</h4>
    <p>PL/SQL code is compiled with an optimization level of 0, 1, or 2.  (As mentioned above, the <code>_PLSQL_OBJECT_SETTINGS</code> views can be queried to determine with what optimization level a PL/SQL object was compiled.)  The lower the optimization level, the more debug info is generated (but the slower it runs), and vice versa.  In SQL Developer, the default optimization level is zero (maximum debug info, and also maximum slowness).  This setting can be found under <b>Tools > Preferences... > Database > PL/SQL Compiler > Optimization Level</b>:</p>
    <img style="display: block; margin: auto; width: 700px; height: 500px;" src="settings.png" alt="PL/SQL Compiler settings" />
    <p>Note that this setting applies only when compiling PL/SQL code via the editor buttons.  Compiling via the <b>Compile</b> and <b>Compile for Debug</b> items on the context menu has different results:</p>
    <img style="display: block; margin: auto; width: 322px; height: 392px;" src="menu.png" alt="context menu" />
    <ul>
      <li><b>Compile</b> = optimization level 2 (no debug info)</li>
      <li><b>Compile for Debug</b> = optimization level 1 (some debug info)</li>
    </ul>
    <p><a href="http://www.devshed.com/c/a/oracle/compiling-plsql-code-for-an-oracle-database/">This article</a> and <a href="http://stevenfeuersteinonplsql.blogspot.com/2016/08/plsql-optimization-levels-and-native.html">this blog post</a> explain optimization levels pretty well.</p>
    <footer>Copyright &copy; 2016-21 Jeffrey Paul Bourdier</footer>
  </body>
</html>
